\chapter{Background}
\label{chap:background}

This chapter provides the background knowledge helpful for comprehending the following chapters. We first give an overview of runtime verification in general and afterward describe the specification language MFODL and the runtime monitoring system \MonPoly in more detail.

\section{Runtime verification}
Runtime verification (RV) is pursued as a complementary verification strategy besides other approaches such as testing or formal verification. Compared to other strategies, runtime verification can be used to verify the correct behavior of a system during its runtime \cite{leuckerBriefAccountRuntime2009}. In general, we want to detect deviations in the behavior of a system from its specification. On the detection of divergence, a runtime verification tool may solely act as a reporter or influence the run of the system under monitoring, where the latter is known as enforcement \cite{leuckerBriefAccountRuntime2009}. Formally, a run of a system can be modeled as a possibly infinite sequence of program states \cite{leuckerBriefAccountRuntime2009}, from now on called program trace. A \textit{correctness property} is equal to a subset of program traces that adhere to a given system specification.

A \textit{monitor} is an algorithm that, in its simplest form, produces a boolean verdict, indicating if the current program trace of a monitored system is an element of a given correctness property. We further differentiate between online and offline monitoring: In the former, the monitor checks the execution of a system in real time by incrementally processing new system states from an ongoing program trace. In the latter, a monitor analyses a (finite) program trace of a previous system run. During online monitoring of an infinite trace, some properties may not always be verifiable in finite time. For example, if a \textit{liveness property} is not satisfied by an infinite trace, there exists no finite prefix of the trace acting as a witness for refutation \cite{havelundRuntimeVerificationPropositional2018}.

Usually, a monitor is automatically generated based on a higher-level specification \cite{leuckerBriefAccountRuntime2009}. When we use the term \textit{specification language}, we imply a language to formulate the specification for generating a monitor. MFODL and the extension CMFODL, presented in this work, are specification languages. In contrast, \MonPoly is an implementation of a monitor generator from MFODL specifications \cite{basinMonPolyMonitoringTool2017}. From now on, we call specifications written in MFODL \textit{formulas} and \MonPoly the \textit{monitoring system}.

\section{MFODL}
MFODL \cite{basinFormallyVerifiedOptimized2020} is the result of combining \textit{Metric Dynamic Logic} (MDL) \cite{dankrsticAlmostEventRateIndependent} and \textit{Metric First-Order Temporal Logic} (MFOTL) \cite{chomickiEfficientCheckingTemporal1995} with additional features \cite{traytel16MetricFirstOrder}. While it inherits the temporal operators from MFOTL, it also supports regular expression over program traces introduced by MDL. Further features include aggregation operators introduced to MFOTL by Basin et al. \cite{basinMonitoringTemporalFirstorder2015}.

MFODL formulas are interpreted over a temporal structure consisting of a sequence of tuples, each consisting of a timestamp and a finite set of relations. Values of relations are elements of a possibly infinite domain $|\mathcal{D}|$. The formula $r(a_1, a_2, \dots, a_k)$ for a $k$-ary predicate $r$ is evaluated as true at a time point $i$ for values $a_1, a_2, \dots, a_k \in |\mathcal{D}|$, whenever the tuple $(a_1, a_2, \dots, a_k)$ is an element of the relation $r$ at the $i$-th element of the temporal structure. While the domain $|\mathcal{D}|$ is not fixed, one important limitation of MFODL is the fact that each value in $|\mathcal{D}|$ is regarded to be atomic: neither the syntax nor the semantics of MFODL allows accessing fields of compound values. The extension CMFODL presented in this work improves upon this. Section \ref{sec:extensions_mfold_syntax} provides an overview of the supported syntax, and Section \ref{sec:mfodl_semantics} formalizes the semantics of CMFODL formulas.

\section{MonPoly}
\label{sec:backgroun_monpoly}
\MonPoly is a runtime verification tool accepting specifications in MFODL. To effectively monitor policies, \MonPoly only handles a syntactic fragment of MFODL \cite{basinMonPolyMonitoringTool2017}. For once, all intervals of future temporal operators must be bounded.  Furthermore, all intermediate results must be finite when evaluating a formula bottom-up. Finally, the domain of values accepted as part of a relation in a temporal structure is limited to the primitive types $\mathsf{string},\ \mathsf{int},\ \mathsf{float}$, and $\mathsf{regexp}$ \cite{basinMonPolyMonitoringTool2017}.

Besides a program trace, \MonPoly requires a signature file and a formula file as input. The signature file describes the first-order signature used by the formula. The formula file contains the specification written in MFODL \cite{basinMonPolyMonitoringTool2017}. The accepted grammar of these files is described in Sections \ref{sec:grammar_formulas} and \ref{sec:grammar_signatures}. The log to monitor can either be provided as a file for offline monitoring or as a stream to standard input for online monitoring. The log represents a finite temporal structure by enumerating the relations tuple by tuple for each time point in increasing order. This work extends \MonPoly such that it accepts specifications written in CMFODL and can parse JSON formatted log files.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
