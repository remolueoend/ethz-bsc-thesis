\chapter{Related Work}
\label{chap:related_work}

This chapter looks at other approaches with expressive specification languages for runtime verification. We focus on languages that provide support for complex-structured event data, as they are pursuing a similar goal as CMFODL.

\section{LOGSCOPE}
\textsc{LogScope} is a runtime verification tool initially developed for NASA's Jet Propulsion Laboratory \cite{barringerFormalAnalysisLog2010}. It provides a temporal specification language that is translated into an automata-based monitor. Specifications can be formulated in either temporal logic formulas or a parameterized $\forall$-automaton that supports event parameters and universal quantification. Constraints on events, called event predicates, can be specified in general \textsc{Python} expressions over arbitrary data structures carried by the events. Furthermore, \textsc{LogScope} allows formulating custom side effects in \textsc{Python} code, called event actions, triggered on the successful evaluation of an event predicate. Side effects may manage global state referenced in event predicates. \textsc{LogScope} may therefore be regarded as a mix of declarative and operational language. However, compared to CMFODL, neither \textsc{LogScope}'s temporal logic pattern, nor its automaton language allows referencing data of past events in an event predicate. Certain properties formulated in CMFODL, such as $\mathsf{A(x) \to \mfodlOnce_{[0,*]} \left( B(y) \land y = x \right)}$, can therefore not be represented in \textsc{LogScope}. Furthermore, side effects may introduce additional complexity to a specification, reducing its comprehensibility. Finally, the \textsc{LogScope} framework is not suitable for online runtime verification: a program trace is consumed as a \textsc{Python} list of arbitrary event objects and can not be streamed in real-time.

\section{LTL-FO\textsuperscript{+}}
LTL-FO\textsuperscript{+} \cite{halleRuntimeMonitoringMessageBased2008} is the runtime verification counterpart to CTL-FO\textsuperscript{+} \cite{halleModelCheckingDataAware2007} developed for model checking. LTL-FO\textsuperscript{+} supports online runtime monitoring over program traces consisting of arbitrary XML-based messages. Where specifications formulated in CTL-FO\textsuperscript{+} describe properties of all possible execution paths, specifications written in LTL-FO\textsuperscript{+} focus on a single program trace. A program trace is modeled as a stream of messages, each representing a relation from parameters to values, where values can be of arbitrarily nested data structures. The specification language LTL-FO\textsuperscript{+} is an extension of LTL \cite{bauerRuntimeVerificationLTL2011}. Compared to CMFODL, LTL-FO\textsuperscript{+} introduces quantifiers over parameters in a message, but it lacks support for global quantification over an infinite domain of the variables in a program trace. Similarly to \textsc{LogScope}, it provides no support for referencing past events in a specification, which is CMFODL supports.

\section{PARTRAP}
\textsc{ParTraP} has been developed for the runtime verification of medical devices \cite{bleinExtendingSpecificationPatterns2018}. In this context, a trace consists of inputs captured by device sensors and their interaction with a surgeon. One of the core objectives of \textsc{ParTraP} is to enable software engineers without training in formal methods to formulate trace properties and make them readable by domain experts simultaneously. In \textsc{ParTraP} a program trace is seen as a sequence of events, each represented by an arbitrary nested JSON object. Each event must at least carry its event type and time in a hardcoded format. In contrast, event data is not required to be tagged with their event type when monitored by \MonPolyN. \textsc{ParTraP}'s atomic building blocks are unary \textit{scopes}, such as $\mathsf{before\ A}$ or $\mathsf{after\ first\ B}$ for some events $\mathsf{A, B}$. By nesting scopes, higher-arity scopes can be constructed. Because events may carry list structures as event data, \textsc{ParTraP} provides \textit{local} quantification over values in lists. For instance, the specification $\mathsf{forall\ a\ in\ L,\ P}$ requires the property $\mathsf{P}$ to be satisfied for all values $\mathsf{a}$ in the finite list $\mathsf{L}$. However, compared to CMFODL, support for \textit{global} quantification over the infinite domain of the variables on a whole trace is missing.

\section{HLOLA}
Unlike \MonPoly, $\mathsf{HLola}$ \cite{gorostiagaHLolaVeryFunctional2021} is a stream runtime verification tool. Stream runtime verification (SRV) can be seen as a generalization of monitoring temporal logic formulas. Instead of generating a single Boolean verdict, or a stream of Boolean verdicts produced by \MonPoly, SRV describes the dependencies between output streams (results) and input streams (observations) \cite{gorostiagaStriverStreamRuntime2018}. $\mathsf{HLola}$ uses \textsc{Lola} as its core language but adds support for arbitrary data types. Input streams acting as the program trace under monitoring can be provided in JSON or CSV format. $\mathsf{HLola}$ allows imports of arbitrary library code written in \textsc{Haskell}, from which it inherits all available data types to describe the structure of input and output streams. As SRV is a generalization of runtime verification, $\mathsf{HLola}$ allows the implementation of general LTL operators, including past operators.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
